# -*- coding: utf-8 -*-
"""Kelompok3_Project_BigData_RF_081225 week 14.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jMRI7aAArn4N5suiMRB-cZqTKxCMdbxN

Import Dependencies & Load dataset
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

import plotly.express as px
import plotly.graph_objects as go
import plotly.io as pio
from plotly.subplots import make_subplots
pio.templates.default = "plotly_white"

df = pd.read_csv('https://raw.githubusercontent.com/sonicmortis/Datasets/refs/heads/main/weatherHistory.csv')
df.head()

# Data Understanding: head, info, describe, missing, histograms per feature, corr heatmap

# Pastikan datetime diparse
if 'Formatted Date' in df.columns:
    df['Formatted Date'] = pd.to_datetime(df['Formatted Date'], errors='coerce')

# 1) Quick look
print("=== df.head() ===")
display(df.head(10))

print("\n=== df.info() ===")
print(df.info())

print("\n=== df.describe() ===")
display(df.describe(include='all'))

# 2) Missing values
print("\n=== Missing values per column ===")
print(df.isnull().sum())

# 3) Choose numeric columns to plot
numeric_cols = df.select_dtypes(include=['number']).columns.tolist()

# prefer common weather order if present
preferred_order = ['Temperature (C)', 'Apparent Temperature (C)', 'Humidity',
                   'Wind Speed (km/h)', 'Wind Bearing (degrees)',
                   'Visibility (km)', 'Cloud Cover', 'Pressure (millibars)']

plot_cols = []
for c in preferred_order:
    if c in numeric_cols:
        plot_cols.append(c)
for c in numeric_cols:
    if c not in plot_cols:
        plot_cols.append(c)

print("\nWill plot the following numeric columns (one histogram each):")
print(plot_cols)

# 4) Histograms (one plot per feature)
for col in plot_cols:
    plt.figure(figsize=(8,4))
    series = df[col].dropna()
    if series.nunique() <= 6:
        counts = series.value_counts().sort_index()
        plt.bar(counts.index.astype(str), counts.values)
        plt.xlabel(col)
        plt.ylabel("Count")
        plt.title(f"Distribution (counts) — {col}")
    else:
        plt.hist(series, bins=40)
        plt.xlabel(col)
        plt.ylabel("Frequency")
        plt.title(f"Histogram — {col}")
    plt.tight_layout()
    plt.show()

# 5) Correlation heatmap for numeric features
if len(plot_cols) > 0:
    corr = df[plot_cols].corr()
    plt.figure(figsize=(8,6))
    im = plt.imshow(corr, aspect='auto')
    plt.colorbar(im)
    plt.xticks(range(len(plot_cols)), plot_cols, rotation=90)
    plt.yticks(range(len(plot_cols)), plot_cols)
    plt.title("Correlation matrix (numeric features)")
    plt.tight_layout()
    plt.show()
else:
    print("No numeric columns to compute correlation.")

"""# **Data Cleaning**"""

# DATA CLEANING

# Convert datetime
df['Formatted Date'] = pd.to_datetime(df['Formatted Date'], errors='coerce')

# Sort berdasarkan waktu
df = df.sort_values('Formatted Date').reset_index(drop=True)

# Mengisi missing values pada fitur numerik SAJA (BUKAN target Temperature)
num_cols = df.select_dtypes(include=['float64', 'int64']).columns.tolist()

if 'Temperature (C)' in num_cols:
    num_cols.remove('Temperature (C)')

df[num_cols] = df[num_cols].ffill()

# Drop baris duplicate timestamp
df = df.drop_duplicates(subset='Formatted Date')

print("Data cleaning selesai!")
print(df.info())

# Cek outlier (pisahkan fitur vs target)

def detect_outliers_iqr(dataframe, target_col=None):
    outlier_count = {}
    for col in dataframe.select_dtypes(include=['float64', 'int64']).columns:
        Q1 = dataframe[col].quantile(0.25)
        Q3 = dataframe[col].quantile(0.75)
        IQR = Q3 - Q1
        lower = Q1 - 1.5 * IQR
        upper = Q3 + 1.5 * IQR
        outliers = dataframe[(dataframe[col] < lower) | (dataframe[col] > upper)][col].count()

        label = col
        if target_col and col == target_col:
            label = f"{col} (TARGET)"

        outlier_count[label] = outliers

    return pd.DataFrame.from_dict(outlier_count, orient='index', columns=['Outlier Count'])


print("\n=== OUTLIER PER KOLOM (IQR) ===")
outlier_df = detect_outliers_iqr(df, target_col='Temperature (C)')
display(outlier_df)

#Winsorization (Capping) pada kolom 'Wind Speed (km/h)' dan 'Pressure (millibars)'
columns_to_cap = ['Wind Speed (km/h)', 'Pressure (millibars)']

for col in columns_to_cap:
    lower_bound = df[col].quantile(0.05)
    upper_bound = df[col].quantile(0.95)
    df[col] = np.where(df[col] < lower_bound, lower_bound, df[col])
    df[col] = np.where(df[col] > upper_bound, upper_bound, df[col])

print("\n=== OUTLIER PER KOLOM SETELAH CAPPING (IQR) ===")
outlier_df_after_capping = detect_outliers_iqr(df)
display(outlier_df_after_capping)

# Interpolasi hanya untuk FITUR, bukan target
columns_to_process = ['Apparent Temperature (C)', 'Humidity']

for col in columns_to_process:
    Q1 = df[col].quantile(0.25)
    Q3 = df[col].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR

    # Replace outliers with NaN
    df[col] = np.where((df[col] < lower_bound) | (df[col] > upper_bound), np.nan, df[col])

    # Interpolate NaN values
    df[col] = df[col].interpolate(method='linear')

print("\n=== OUTLIER PER KOLOM SETELAH GANTI NA DAN INTERPOLASI (IQR) ===")
outlier_df_after_nan_and_interpolate = detect_outliers_iqr(df)
display(outlier_df_after_nan_and_interpolate)

"""# **Feature Selection**"""

# Mutual Information

from sklearn.feature_selection import mutual_info_regression
from sklearn.preprocessing import LabelEncoder

df_mi = df.copy()

cat_cols = df_mi.select_dtypes(include='object').columns
for c in cat_cols:
    df_mi[c] = LabelEncoder().fit_transform(df_mi[c].astype(str))

X = df_mi.drop(columns=['Temperature (C)', 'Formatted Date'])
y = df_mi['Temperature (C)']

mi = mutual_info_regression(X, y, random_state=0)

mi_scores = pd.Series(mi, index=X.columns).sort_values(ascending=False)
print(mi_scores)

# RF Feature Importance

from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import LabelEncoder

df_rf = df.copy()

for c in df_rf.select_dtypes(include='object').columns:
    df_rf[c] = LabelEncoder().fit_transform(df_rf[c].astype(str))

X = df_rf.drop(columns=['Temperature (C)', 'Formatted Date'])
y = df_rf['Temperature (C)']

rf = RandomForestRegressor(n_estimators=300, random_state=0)
rf.fit(X, y)

importances = pd.Series(rf.feature_importances_, index=X.columns)
print(importances.sort_values(ascending=False))

mi_rank = mi_scores.sort_values(ascending=False).index.tolist()
rf_rank = importances.sort_values(ascending=False).index.tolist()

all_features = set(mi_rank + rf_rank)

vote_result = {}
for f in all_features:
    votes = 0
    if f in mi_rank[:8]: votes += 1
    if f in rf_rank[:8]: votes += 1
    vote_result[f] = votes

pd.DataFrame(sorted(vote_result.items(), key=lambda x: -x[1]),
             columns=['Feature', 'Votes'])

selected_features = [
    'Formatted Date',
    'Humidity',
    'Pressure (millibars)',
    'Visibility (km)',
    'Wind Speed (km/h)',
    'Apparent Temperature (C)',
    'Temperature (C)'   # TARGET
]

df = df[selected_features]
df.head()

"""# **Resampling ke Hourly**"""

# RESAMPLE KE HOURLY (UNTUK REGRESI TEMPERATURE)

df_resampled = df.set_index('Formatted Date')

# Resample pakai rata-rata untuk semua fitur numerik termasuk Temperature
df_hourly = df_resampled.resample('1h').mean()

# Forward fill HANYA untuk FITUR, bukan target
feature_cols = df_hourly.columns.tolist()
if 'Temperature (C)' in feature_cols:
    feature_cols.remove('Temperature (C)')

df_hourly[feature_cols] = df_hourly[feature_cols].ffill()

df_hourly = df_hourly.reset_index()

print("Resampling selesai!")
print(df_hourly.info())

"""# **Generate Lag Features**"""

# 5️⃣ LAG FEATURE ENGINEERING (UNTUK REGRESI TEMPERATURE)

lag_cols = [
    'Temperature (C)',   # historical temp as feature
    'Humidity',
    'Wind Speed (km/h)',
    'Visibility (km)',
    'Pressure (millibars)'
]

def create_lags(df, hours=24):
    df = df.copy()
    for col in lag_cols:
        for lag in range(1, hours + 1):
            df[f"{col}_lag{lag}"] = df[col].shift(lag)
    return df

df_lag = create_lags(df_hourly, hours=24)

# Drop NaN hasil shifting
df_lag = df_lag.dropna().reset_index(drop=True)

print("Lag features selesai!")
print(df_lag.shape)

"""# **Time-based Train-test Split**"""

# TIME-BASED TRAIN-TEST SPLIT (REGRESI TEMPERATURE)

train_size = int(len(df_lag) * 0.8)
train = df_lag.iloc[:train_size].copy()
test  = df_lag.iloc[train_size:].copy()

# Target = Temperature (C)
y_train = train['Temperature (C)']
y_test  = test['Temperature (C)']

# Fitur = semua kecuali target & datetime
X_train = train.drop(columns=['Temperature (C)', 'Formatted Date'])
X_test  = test.drop(columns=['Temperature (C)', 'Formatted Date'])

print("Split selesai!")
print("Train:", X_train.shape, y_train.shape)
print("Test :", X_test.shape, y_test.shape)

"""# **Scaling**"""

# SCALING (MinMaxScaler)

from sklearn.preprocessing import MinMaxScaler

scaler = MinMaxScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled  = scaler.transform(X_test)

print("Scaling selesai!")
print("X_train_scaled:", X_train_scaled.shape)
print("X_test_scaled :", X_test_scaled.shape)

"""# **Supervised Time Series Forecasting with Random Forest**"""

from sklearn.ensemble import RandomForestRegressor

rf_model = RandomForestRegressor(n_estimators=300, random_state=0)
rf_model.fit(X_train_scaled, y_train)

print("Model Random Forest Regressor berhasil dilatih!")

"""## Random Forest Prediction


"""

y_pred_rf = rf_model.predict(X_test_scaled)

print("Predictions using Random Forest Regressor completed!")

"""**Evaluasi Random Forest**"""

from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import numpy as np

mae_rf = mean_absolute_error(y_test, y_pred_rf)
mse_rf = mean_squared_error(y_test, y_pred_rf)
rmse_rf = np.sqrt(mse_rf)
r2_rf = r2_score(y_test, y_pred_rf)

print("=== Evaluasi Random Forest Regressor (Forecasting) ===")
print("MAE :", mae_rf)
print("RMSE:", rmse_rf)
print("R²  :", r2_rf)

"""**Plot Actual vs Prediction**"""

import matplotlib.pyplot as plt

plt.figure(figsize=(12,5))
plt.plot(y_test.values, label="Actual Temperature")
plt.plot(y_pred_rf, label="Predicted Temperature (Random Forest)")
plt.title("Actual vs Predicted Temperature — Random Forest Regressor")
plt.xlabel("Time Index")
plt.ylabel("Temperature (C)")
plt.legend()
plt.grid()
plt.show()

"""**Residual Analysis (Nilai Error)**"""

residuals_rf = y_test.values - y_pred_rf

plt.figure(figsize=(10,4))
plt.plot(residuals_rf)
plt.title("Residual Plot — Random Forest Regressor")
plt.xlabel("Time Index")
plt.ylabel("Residual Error")
plt.grid()
plt.show()